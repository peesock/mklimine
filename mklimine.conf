# vim: ft=sh
# shellcheck disable=SC2078 disable=SC2030 disable=SC2031

### File format:
# "Sections" are function names surrounded by [ brackets ] that contain text until the next section.
# For each section, the $Buffer file is set to the contents of that section, and the function
# represented by the section name is executed.
#
# The most useful function is Parse(), which parses $Buffer according to the Limine config format,
# but evaluates values as shell expressions, allowing for dynamic config creation.
#
# The text at the beginning of the file is not part of a section, and is evaluated before operating
# on sections. This lets you set custom variables and functions.

### Pre-defined variables:
# $Output -- file , /dev/stdout by default.
# $Buffer -- file holding the contents of the current section.
# $ESP -- directory for system boot partition (MAY BE EMPTY)
# $OS_* -- variables from /etc/os-release, prepended with "OS_".

### Pre-defined functions:
# Parse() -- parse over $Buffer, evaluating values as shell expressions, appending to $Output.
# Print() -- same as echo, but does not interpret escape sequences.

### Exit functions:
# Exiter() -- runs exit functions from the $ExitFuncs list on exit.
# Write() -- decides whether to write $TempOutput to $Output.
# Cleanup() -- removes temp files.

### Example config:

# if you want to write for realz:
# Output=$ESP/limine.conf

# Very useful functions (and variables)
[ -e ./extra-functions ] && . ./extra-functions || {
	path=$(realpath -- "$0")
	. "${path%/*/*}/share/mklimine/extra-functions"
}

[ Parse ]
# Add some global Limine options
timeout: 3
default_entry: 1
hash_mismatch_panic: no

# Add our autogenerated entry, $OS_NAME comes from os-release
/+${OS_NAME}
[ Archauto ] # from extra-functions, generates subentries from images in /boot
	//${KNAME}
	protocol: linux
	comment: ${KVER}
	comment: ${RAMFS}
	path: "guid($GUID):/${KFILE}"
	module_path: "guid($GUID):/${RAMFS}"
	cmdline: loglevel=4 splash nvidia-drm.modeset=1 root=/dev/mapper/root rw \
		cryptdevice=UUID=f2e12b7e-2299-2843-a5f6-167faca082c6:root

[ Parse ] # I don't dual boot windows but if you did it would look something like this
/Windows 10
	protocol: efi_chainload
	path: "boot():/EFI/Microsoft/Boot/bootmgfw.efi"
