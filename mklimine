#!/bin/sh
# TODO:
# For each section, function stdout is sent to an isolated tmpfile, and only appended to $Output if
# there were no errors. Removes the need for a global set -e.
# Create more built in things, for eg:
#   - UKI stuff eventually...
# Libaplm hooks.

set -eu
Help(){
	cat <<- EOF
	Usage:
	mklimine [OPTS] [--] [ARGS]
	ARGS are sent to mklimine config.

	Options:
	-h         print help
	-c PATH    set mklimine config to PATH
	-s SHELL   use SHELL instead of /bin/sh
	-S SHELL   like -s, but allow incompatible shells

	Environment:
	MKLIMINE_CONFIG = path to mklimine config
	EOF
	exit 0
}

Output=/dev/stdout
Config=${MKLIMINE_CONFIG:-/etc/mklimine.conf}
while [ $# -gt 0 ]; do
	case $1 in
		--)
			shift
			break;;
		-h|--help)
			Help
			;;
		-s)
			# use different shell
			compatshells='bash dash ash ksh sh'
			sh=$2
			shift 2
			for s in $compatshells; do
				[ "$s" = "$sh" ] && exec "$sh" -- "$0" "$@"
			done
			echo "Compatible shells: $compatshells" >&2
			exit 1
			;;
		-S)
			# force shell
			sh=$2
			shift 2
			exec "$sh" -- "$0" "$@";;
		-c)
			Config=$2
			shift 2;;
		*)
			break;;
	esac
done
[ -e "$Config" ] && [ ! -d "$Config" ] || {
	echo "$Config" does not exist. >&2
	exit 1
}

Print(){
	printf %s\\n "$*"
}

Parse(){
	Even=
	<"$Buffer" awk '{
		if (ORS == ""){
			ORS="\n"; sub(/^\s+/, ""); print $0
		} else {
			if (match($0, /^\s*((\S+:)|\/+)\s*/)){
				key=substr($0, 1, RLENGTH)
				print "X" key "X"
				val=substr($0, RLENGTH+1)
				if (match(val, /\\$/)){
					if (!sub(/\\\\/, "\\", val)){
						ORS=""
						val=substr(val, 1, length(val)-1)
					}
				}
				print val
			} else if ($0 ~ /^\s*$/){
				print ORS
			}
		}
	}' | while read -r Line; do
		Line=${Line%X}
		Line=${Line#X}
		[ "${Even-}" ] && {
			eval Print "$Line"
			Even=
			continue
		}
		Even=1
		printf %s "$Line"
	done >>"$TempOutput"
}

Exiter(){
	Status=$?
	for func in $ExitFuncs; do
		"$func"
	done
	return $Status
}

Cleanup(){
	rm "$Fifo" "$Buffer" "$TempOutput"
}

Write(){
	if [ -f "$Output" ] || [ ! -e "$Output" ]; then
		if [ "$Status" -eq 0 ]; then
			# See if output is actually different from the existing file
			if diff -q -- "$TempOutput" "$Output" >/dev/null 2>&1; then
				echo "No difference in config :)" >&2
			else
				# Make backup
				[ -e "$Output" ] && mv "$Output" "$Output.old"
				cat < "$TempOutput" > "$Output"
				echo "Config created :)" >&2
			fi
		else
			echo "Error detected. Not updating $Output" >&2
		fi
	elif [ ! -d "$Output" ]; then # special file (like stdout)
		cat < "$TempOutput" > "$Output"
	else
		echo "$Output is a directory." >&2
		return 1
	fi
}

TempOutput=$(mktemp)
Buffer=$(mktemp)
Fifo=$(mktemp -u)
mkfifo "$Fifo"
ExitFuncs='Write Cleanup'
trap 'Exiter' EXIT
trap exit INT TERM HUP

# set OS_* variables
while read -r line; do
	eval "OS_$line"
done < /etc/os-release

# attempt to set $ESP variable
while true; do
	ESP=$(lsblk -o mountpoint,parttypename --json --tree |
		jq -r '.blockdevices.[] | ., .children.[] |
		select(.parttypename | select(. != null) | test("^efi"; "i")).mountpoint')
	[ "$ESP" ] && break
	for dir in efi EFI boot; do
		[ -d "/$dir" ] && ESP=/$dir && break 2
	done
	unset ESP
	break
done

(printf '\n1 '; awk 'BEGIN{ORS=""}
{
	if ($0 ~ /^\s*\[ \S.* \]\s*(#.*)?$/){
		gsub(/(^\s*\[ )|( \]\s*(#.*)?$)/, "")
		print NR-1 "\n" $0 "\n" NR+1 " "
	}
}
END{print NR "\n"}') <"$Config" >"$Fifo" &

Even=
while read -r Field1 Field2; do
	[ "$Even" ] && {
		awk '{if (NR > '"$Field2"') exit; if (NR >= '"$Field1"') print $0}' <"$Config" >"$Buffer"
		if [ "${Exec-}" ]; then
			eval "$Exec"
		else
			# first section
			eval '
				dummyfunc(){
					'"$(cat "$Buffer")"'
				}
				dummyfunc "$@"
			'
		fi
		Even=
		continue
	}
	Exec=$Field1
	Even=1
done <"$Fifo"
